import { Document, Packer, Paragraph, HeadingLevel, TextRun, AlignmentType, Table, TableRow, TableCell, WidthType } from 'docx';
import { saveAs } from 'file-saver';

/**
 * Export a markdown pitch deck as a formatted DOCX file.
 * Parses common markdown patterns (headers, bold, italic, lists, horizontal rules)
 * and generates a professional Word document.
 */
export async function exportDOCX(markdownText, title = 'Master Pitch Deck') {
    const lines = markdownText.split('\n');
    const docChildren = [];

    // Cover page
    docChildren.push(
        new Paragraph({ spacing: { after: 600 } }),
        new Paragraph({
            children: [new TextRun({ text: title, bold: true, size: 56, font: 'Calibri' })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 200 },
        }),
        new Paragraph({
            children: [new TextRun({
                text: `Generated by NatHistory-Writer • ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}`,
                size: 22,
                color: '888888',
                font: 'Calibri',
            })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 },
        }),
        new Paragraph({
            children: [new TextRun({ text: '─'.repeat(60), color: 'CCCCCC', size: 20 })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 600 },
        })
    );

    // Parse markdown lines


    for (let li = 0; li < lines.length; li++) {
        const rawLine = lines[li];
        const line = rawLine.trim();

        // Skip empty lines
        if (!line) {

            docChildren.push(new Paragraph({ spacing: { after: 100 } }));
            continue;
        }

        // Horizontal rule
        if (/^---+$/.test(line) || /^===+$/.test(line) || /^___+$/.test(line)) {
            docChildren.push(
                new Paragraph({
                    children: [new TextRun({ text: '─'.repeat(60), color: 'CCCCCC', size: 18 })],
                    alignment: AlignmentType.CENTER,
                    spacing: { before: 200, after: 200 },
                })
            );
            continue;
        }

        // Headers
        const h1 = line.match(/^# (.+)$/);
        if (h1) {
            docChildren.push(new Paragraph({
                children: [new TextRun({ text: h1[1], bold: true, size: 36, font: 'Calibri' })],
                heading: HeadingLevel.HEADING_1,
                spacing: { before: 400, after: 200 },
            }));
            continue;
        }

        const h2 = line.match(/^## (.+)$/);
        if (h2) {
            docChildren.push(new Paragraph({
                children: [new TextRun({ text: h2[1], bold: true, size: 30, font: 'Calibri' })],
                heading: HeadingLevel.HEADING_2,
                spacing: { before: 300, after: 150 },
            }));
            continue;
        }

        const h3 = line.match(/^### (.+)$/);
        if (h3) {
            docChildren.push(new Paragraph({
                children: [new TextRun({ text: h3[1], bold: true, size: 26, font: 'Calibri' })],
                heading: HeadingLevel.HEADING_3,
                spacing: { before: 200, after: 100 },
            }));
            continue;
        }

        const h4 = line.match(/^#### (.+)$/);
        if (h4) {
            docChildren.push(new Paragraph({
                children: [new TextRun({ text: h4[1], bold: true, size: 24, font: 'Calibri', italics: true })],
                heading: HeadingLevel.HEADING_4,
                spacing: { before: 200, after: 100 },
            }));
            continue;
        }

        // List items
        const listMatch = line.match(/^[-*•] (.+)$/);
        const numberedMatch = line.match(/^(\d+)\. (.+)$/);
        if (listMatch || numberedMatch) {

            const text = listMatch ? listMatch[1] : numberedMatch[2];
            const prefix = listMatch ? '• ' : `${numberedMatch[1]}. `;
            docChildren.push(new Paragraph({
                children: parseInlineFormatting(prefix + text),
                indent: { left: 360 },
                spacing: { after: 60 },
            }));
            continue;
        }

        // Table detection — collect contiguous pipe-delimited lines
        if (line.startsWith('|') && line.endsWith('|')) {
            const tableLines = [line];
            // Look ahead for more table rows
            let j = li + 1;
            while (j < lines.length) {
                const nextLine = lines[j].trim();
                if (nextLine.startsWith('|') && nextLine.endsWith('|')) {
                    tableLines.push(nextLine);
                    j++;
                } else {
                    break;
                }
            }
            // Advance loop index past consumed table lines
            li = j - 1;

            // Parse table
            const parseCells = (row) => row.split('|').slice(1, -1).map(c => c.trim());
            const headerCells = parseCells(tableLines[0]);
            const isSeparator = (row) => /^[\s|:-]+$/.test(row);
            const dataRows = tableLines.filter((r, i) => i > 0 && !isSeparator(r)).map(parseCells);

            const tableRowObjects = [];

            // Header row
            tableRowObjects.push(new TableRow({
                children: headerCells.map(cell => new TableCell({
                    children: [new Paragraph({ children: [new TextRun({ text: cell, bold: true, size: 20, font: 'Calibri' })] })],
                    shading: { fill: 'F0F0F0' },
                })),
                tableHeader: true,
            }));

            // Data rows
            for (const cells of dataRows) {
                tableRowObjects.push(new TableRow({
                    children: cells.map(cell => new TableCell({
                        children: [new Paragraph({ children: parseInlineFormatting(cell) })],
                    })),
                }));
            }

            if (tableRowObjects.length > 0) {
                docChildren.push(new Table({
                    rows: tableRowObjects,
                    width: { size: 9360, type: WidthType.DXA },
                }));
                docChildren.push(new Paragraph({ spacing: { after: 100 } }));
            }
            continue;
        }

        // Blockquote styling
        const blockquoteMatch = line.match(/^>\s*(.+)$/);
        if (blockquoteMatch) {
            docChildren.push(new Paragraph({
                children: [new TextRun({ text: blockquoteMatch[1], italics: true, size: 22, font: 'Calibri', color: '555555' })],
                indent: { left: 720 },
                spacing: { after: 80 },
            }));
            continue;
        }

        // Regular paragraph with inline formatting
        docChildren.push(new Paragraph({
            children: parseInlineFormatting(line),
            spacing: { after: 80 },
        }));
    }

    // Build the document
    const doc = new Document({
        sections: [{
            properties: {
                page: {
                    margin: { top: 1440, right: 1440, bottom: 1440, left: 1440 },
                },
            },
            children: docChildren,
        }],
    });

    // Generate and save
    const blob = await Packer.toBlob(doc);
    const filename = title.replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_') + '.docx';
    saveAs(blob, filename);
}

/**
 * Parse inline markdown formatting (bold, italic, code) into TextRun objects.
 */
function parseInlineFormatting(text) {
    const runs = [];
    // Regex to split on **bold**, *italic*, `code`, and ***bold italic***
    const regex = /(\*\*\*(.+?)\*\*\*|\*\*(.+?)\*\*|\*(.+?)\*|`(.+?)`)/g;
    let lastIndex = 0;
    let match;

    while ((match = regex.exec(text)) !== null) {
        // Add text before the match
        if (match.index > lastIndex) {
            runs.push(new TextRun({ text: text.slice(lastIndex, match.index), size: 22, font: 'Calibri' }));
        }

        if (match[2]) {
            // ***bold italic***
            runs.push(new TextRun({ text: match[2], bold: true, italics: true, size: 22, font: 'Calibri' }));
        } else if (match[3]) {
            // **bold**
            runs.push(new TextRun({ text: match[3], bold: true, size: 22, font: 'Calibri' }));
        } else if (match[4]) {
            // *italic*
            runs.push(new TextRun({ text: match[4], italics: true, size: 22, font: 'Calibri' }));
        } else if (match[5]) {
            // `code`
            runs.push(new TextRun({ text: match[5], font: 'Consolas', size: 20, color: '666666' }));
        }

        lastIndex = match.index + match[0].length;
    }

    // Add remaining text
    if (lastIndex < text.length) {
        runs.push(new TextRun({ text: text.slice(lastIndex), size: 22, font: 'Calibri' }));
    }

    // If no runs were created, add the full text
    if (runs.length === 0) {
        runs.push(new TextRun({ text, size: 22, font: 'Calibri' }));
    }

    return runs;
}
