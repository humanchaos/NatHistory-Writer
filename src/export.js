import { Document, Packer, Paragraph, HeadingLevel, TextRun, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';

/**
 * Export a markdown pitch deck as a formatted DOCX file.
 * Parses common markdown patterns (headers, bold, italic, lists, horizontal rules)
 * and generates a professional Word document.
 */
export async function exportDOCX(markdownText, title = 'Master Pitch Deck') {
    const lines = markdownText.split('\n');
    const docChildren = [];

    // Cover page
    docChildren.push(
        new Paragraph({ spacing: { after: 600 } }),
        new Paragraph({
            children: [new TextRun({ text: title, bold: true, size: 56, font: 'Calibri' })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 200 },
        }),
        new Paragraph({
            children: [new TextRun({
                text: `Generated by NatHistory-Writer • ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}`,
                size: 22,
                color: '888888',
                font: 'Calibri',
            })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 },
        }),
        new Paragraph({
            children: [new TextRun({ text: '─'.repeat(60), color: 'CCCCCC', size: 20 })],
            alignment: AlignmentType.CENTER,
            spacing: { after: 600 },
        })
    );

    // Parse markdown lines
    let inList = false;

    for (const rawLine of lines) {
        const line = rawLine.trim();

        // Skip empty lines
        if (!line) {
            if (inList) inList = false;
            docChildren.push(new Paragraph({ spacing: { after: 100 } }));
            continue;
        }

        // Horizontal rule
        if (/^---+$/.test(line) || /^===+$/.test(line) || /^___+$/.test(line)) {
            docChildren.push(
                new Paragraph({
                    children: [new TextRun({ text: '─'.repeat(60), color: 'CCCCCC', size: 18 })],
                    alignment: AlignmentType.CENTER,
                    spacing: { before: 200, after: 200 },
                })
            );
            continue;
        }

        // Headers
        const h1 = line.match(/^# (.+)$/);
        if (h1) {
            docChildren.push(new Paragraph({
                children: [new TextRun({ text: h1[1], bold: true, size: 36, font: 'Calibri' })],
                heading: HeadingLevel.HEADING_1,
                spacing: { before: 400, after: 200 },
            }));
            continue;
        }

        const h2 = line.match(/^## (.+)$/);
        if (h2) {
            docChildren.push(new Paragraph({
                children: [new TextRun({ text: h2[1], bold: true, size: 30, font: 'Calibri' })],
                heading: HeadingLevel.HEADING_2,
                spacing: { before: 300, after: 150 },
            }));
            continue;
        }

        const h3 = line.match(/^### (.+)$/);
        if (h3) {
            docChildren.push(new Paragraph({
                children: [new TextRun({ text: h3[1], bold: true, size: 26, font: 'Calibri' })],
                heading: HeadingLevel.HEADING_3,
                spacing: { before: 200, after: 100 },
            }));
            continue;
        }

        const h4 = line.match(/^#### (.+)$/);
        if (h4) {
            docChildren.push(new Paragraph({
                children: [new TextRun({ text: h4[1], bold: true, size: 24, font: 'Calibri', italics: true })],
                heading: HeadingLevel.HEADING_4,
                spacing: { before: 200, after: 100 },
            }));
            continue;
        }

        // List items
        const listMatch = line.match(/^[-*•] (.+)$/);
        const numberedMatch = line.match(/^(\d+)\. (.+)$/);
        if (listMatch || numberedMatch) {
            inList = true;
            const text = listMatch ? listMatch[1] : numberedMatch[2];
            const prefix = listMatch ? '• ' : `${numberedMatch[1]}. `;
            docChildren.push(new Paragraph({
                children: parseInlineFormatting(prefix + text),
                indent: { left: 360 },
                spacing: { after: 60 },
            }));
            continue;
        }

        // Regular paragraph with inline formatting
        docChildren.push(new Paragraph({
            children: parseInlineFormatting(line),
            spacing: { after: 80 },
        }));
    }

    // Build the document
    const doc = new Document({
        sections: [{
            properties: {
                page: {
                    margin: { top: 1440, right: 1440, bottom: 1440, left: 1440 },
                },
            },
            children: docChildren,
        }],
    });

    // Generate and save
    const blob = await Packer.toBlob(doc);
    const filename = title.replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_') + '.docx';
    saveAs(blob, filename);
}

/**
 * Parse inline markdown formatting (bold, italic, code) into TextRun objects.
 */
function parseInlineFormatting(text) {
    const runs = [];
    // Regex to split on **bold**, *italic*, `code`, and ***bold italic***
    const regex = /(\*\*\*(.+?)\*\*\*|\*\*(.+?)\*\*|\*(.+?)\*|`(.+?)`)/g;
    let lastIndex = 0;
    let match;

    while ((match = regex.exec(text)) !== null) {
        // Add text before the match
        if (match.index > lastIndex) {
            runs.push(new TextRun({ text: text.slice(lastIndex, match.index), size: 22, font: 'Calibri' }));
        }

        if (match[2]) {
            // ***bold italic***
            runs.push(new TextRun({ text: match[2], bold: true, italics: true, size: 22, font: 'Calibri' }));
        } else if (match[3]) {
            // **bold**
            runs.push(new TextRun({ text: match[3], bold: true, size: 22, font: 'Calibri' }));
        } else if (match[4]) {
            // *italic*
            runs.push(new TextRun({ text: match[4], italics: true, size: 22, font: 'Calibri' }));
        } else if (match[5]) {
            // `code`
            runs.push(new TextRun({ text: match[5], font: 'Consolas', size: 20, color: '666666' }));
        }

        lastIndex = match.index + match[0].length;
    }

    // Add remaining text
    if (lastIndex < text.length) {
        runs.push(new TextRun({ text: text.slice(lastIndex), size: 22, font: 'Calibri' }));
    }

    // If no runs were created, add the full text
    if (runs.length === 0) {
        runs.push(new TextRun({ text, size: 22, font: 'Calibri' }));
    }

    return runs;
}
